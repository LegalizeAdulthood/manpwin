/*
    BigFn.cpp a module for the per pixel calculations of Bignum fractals. 
    
    Written in Microsoft Visual 'C++' by Paul de Leeuw.

    This program is written in "standard" C. Hardware dependant code
    (console drivers & serial I/O) is in separate machine libraries.
*/

#ifdef SPLATTTT
#include	<math.h>
#include	<stdio.h>
#include	"manp.h"
#include	"complex.h"
#include	"big.h"
#include	"fractype.h"
#include	"BigDouble.h"
#include	"BigComplex.h"
#include	"fractalp.h"

//static	BigDouble	realimagBig;
static	double		distance, absolute;
extern	BigDouble	BigBailout;
extern	double		rqlim;			// bailout level

extern	BigComplex	zBig, qBig;
//	BigComplex	aBig, a2Big, aa3Big, bBig, l2Big, lm5Big, lp5Big, ozBig, /*sqrBig, */t2Big, t3Big, vBig;

/**************** a handy little debugging tool *********************/
#ifdef	_DEBUG
extern	HWND		PixelHwnd;	// pointer to handle for pixel updating
//extern	int		decimals;
extern	void	ConvertBignum2String(char *s, mpfr_t num);
void	ShowBignum(BigDouble x, char *Location)
    {
    char    s1[SIZEOF_BF_VARS + 1];
    char    ss[24];
    ConvertBignum2String(s1, x.x);
    sprintf(ss, "bflength=%d", (int)strlen(s1));
    MessageBox (PixelHwnd, s1, Location, MB_ICONEXCLAMATION | MB_OK);
//    MessageBox (PixelHwnd, s1, ss, MB_ICONEXCLAMATION | MB_OK);
    }
#endif
/**************** a handy little debugging tool *********************/


extern	long	iteration;			// globals for speed
extern	BYTE	/*BioFlag, */SpecialFlag;		// tell graphing routine of special conditions
extern	WORD	special;		// special colour for CBIN fractals
extern	int	biomorph;		// biomorph colour
extern	BYTE	degree;			// power
extern	int	decomp;			// number of decomposition colours
extern	BYTE	orbit_flag;		// display orbits?
extern	BYTE	juliaflag;		// Julia implementation of fractal
extern	BYTE	phaseflag;		// 3 phases for type SPECIALNEWT fractals
extern	WORD	type;			// M=mand, J=Julia 1,2,4->
extern	int	subtype;		// B=basin, S=stripe, N=normal
//extern	int	reset_period;		// periodicity checking
extern	int	period_level;		// 0 for no periodicity checking

extern	BYTE	pairflag;		// stereo pair
extern	double	param[];



/**************************************************************************
	Initialise Mandelbrot
***************************************************************************/

int	init_big_mandel(void)

    {
    if (!juliaflag) 
	{
	zBig.x = qBig.x + param[0];
	zBig.y = qBig.y + param[1];
	}
    //    sqrBig = 0.0;
//    realimagBig = 0.0;
    return TRUE;
    }

/**************************************************************************
	Determine count before 'Z' becomes unstable float version
***************************************************************************/

int	do_big_mandel(void)

    {
#ifdef	JONATHAN1
    sqrBig.x = zBig.x.BigSqr();
    sqrBig.y = zBig.y.BigSqr();
    realimagBig = zBig.x * zBig.y;
    zBig.x = qBig.x + sqrBig.x - sqrBig.y;
    zBig.y = realimagBig + realimagBig + qBig.y;
    return (sqrBig.x + sqrBig.y > BigBailout);
#else
    BigDouble	t, realimagBig;
    BigComplex	sqrBig;

    // use direct function calls for Mandelbrot for speed. Approx 10 - 15 % faster.
    mpfr_mul(realimagBig.x, zBig.x.x, zBig.y.x, MPFR_RNDN);
    mpfr_mul(sqrBig.x.x, zBig.x.x, zBig.x.x, MPFR_RNDN);
    mpfr_mul(sqrBig.y.x, zBig.y.x, zBig.y.x, MPFR_RNDN);
    mpfr_sub(t.x, sqrBig.x.x, sqrBig.y.x, MPFR_RNDN);
    mpfr_add(zBig.x.x, qBig.x.x, t.x, MPFR_RNDN);
    mpfr_add(t.x, realimagBig.x, qBig.y.x, MPFR_RNDN);
    mpfr_add(zBig.y.x, realimagBig.x, t.x, MPFR_RNDN);
    mpfr_add(t.x, sqrBig.x.x, sqrBig.y.x, MPFR_RNDN);
/*
    square_bf(sqrBig.x.x, zBig.x.x);
    square_bf(sqrBig.y.x, zBig.y.x);
    mult_bf(realimagBig.x, zBig.x.x, zBig.y.x);
    sub_bf(t.x, sqrBig.x.x, sqrBig.y.x);
    add_bf(zBig.x.x, qBig.x.x, t.x);
    add_bf(t.x, realimagBig.x, qBig.y.x);
    add_bf(zBig.y.x, realimagBig.x, t.x);
    add_bf(t.x, sqrBig.x.x, sqrBig.y.x);
*/
    return (mpfr_cmp(t.x, BigBailout.x) > 0);
#endif
    }

/**************************************************************************
    The Burning Ship fractal, first described and created by Michael Michelitsch and Otto E. Rössler in 1992, is generated by iterating the function
    in the complex plane which will either escape or remain bounded. The difference between this calculation and that for the Mandelbrot set is 
    that the real and imaginary components are set to their respective absolute values before squaring at each iteration. The mapping is non-analytic 
    because its real and imaginary parts do not obey the Cauchy–Riemann equations.
***************************************************************************/

int	do_big_BurningShip(void)

    {
    BigDouble	t, realimagBig;
    BigComplex	sqrBig;

    sqrBig.x = zBig.x.BigSqr();
    sqrBig.y = zBig.y.BigSqr();
    t = zBig.x * zBig.y;
    realimagBig = t.BigAbs();
    zBig.x = qBig.x + sqrBig.x - sqrBig.y;
    zBig.y = realimagBig + realimagBig - qBig.y;
    return (sqrBig.x + sqrBig.y > BigBailout);


/*
    sqr.x = z.x * z.x;
    sqr.y = z.y * z.y; 
    real_imag = fabs(z.x * z.y);
    z.x = sqr.x - sqr.y + q.x;
    z.y = real_imag + real_imag - q.y;
    return ((sqr.x + sqr.y) >= rqlim);
*/
    }

/**************************************************************************
    The Burning Ship fractal for Higher Powers
    The function that is iterated to generate this fractal can be generalized 
    to any arbitrary power:
	z = [|Re(z)| + i |Im(z)|]N + c
    As with the Mandelbrot set, this creates shapes that resemble the original 
    shape but have increasingly many attached arms or buds. Below is a table 
    showing the first few of these.
    With N=2 we get the Burning Ship. The N=3 version has been called the "Bird of Prey."

    The odd powers are symmetric around an axes that are oriented at +/- 45 degrees. 
    This is probably due to the symmetry of the absolute value functions. This 
    property has been mentioned at this site (external link) back in 1999.

    These images are all centered at (0,0) in the complex number plane, and all 
    have a size of 5 horizontally and 4 vertically. This size is a bit too big 
    and results in a lot of blank space in the images, but the N=2 fractal is 
    offset from the origin, so the larger size is needed to have all the images 
    drawn with a consistent location and size so they can be compared accurately.

    Here are a few images of the Cubic Burning Ship. The "bug" images are named 
    because they look like actual bugs, not because of a software error! These 
    are the first deep zoom images ever published of the cubic Burning Ship fractal. 
    The left image size is 1.0e-19, and the right image is 1.0e-23.
    http://www.hpdz.net/StillImages/BurningShip.htm
***************************************************************************/

int	do_big_BurningShipPower(void)

    {
/*
    z.x = fabs(z.x);
    z.y = -fabs(z.y);
    z = CPolynomial(z, degree);	
    z = z+q;
    return (CSumSqr(z) >= rqlim);
*/
    zBig.x = zBig.x.BigAbs();
    zBig.y = -zBig.y.BigAbs();
    zBig = qBig + zBig.CPolynomial(degree);
    return (zBig.CSumSqr() > 4.0);
    }

#ifdef SPLAT
/**************************************************************************
	Init CUBIC fractals 
	Courtesy:  ART MATRIX  PO 880  Ithaca, NY  14851-0880  USA
**************************************************************************/

int	init_big_cubic(void)

    {
    BigComplex	temp;

    period_level = FALSE;			// no periodicity checking
    if (subtype == 'B')				// CBIN 
	{
	t3Big = qBig*3.0;			// T3 = 3*T
	t2Big = qBig.CSqr();			// T2 = T*T
	aBig = (t2Big+1.0)/t3Big;		// A  = (T2 + 1)/T3
						// B  = 2*A*A*A + (T2 - 2)/T3    
	temp = aBig.CCube();			// 2*A*A*A
	temp = temp.CDouble();			// A*A*A
	bBig = (t2Big-2.0)/t3Big+temp;		// B  = 2*A*A*A + (T2 - 2)/T3
	}
    else if (subtype == 'C' || subtype == 'F')	// CCIN or CFIN
	{
	aBig = qBig;				// A = T
						// find B = T + 2*T*T*T
	temp = qBig.CCube();			// B = T*T*T
	if (subtype == 'C')
	    bBig = temp.CDouble()+ qBig;	// B = B * 2 + T
	else
	    {
    	    bBig = (temp- qBig);		// B = B - T
    	    bBig = bBig.CDouble();		// B = B * 2 - 2 * T
	    a2Big = aBig.CDouble();
	    }
	}
    else if (subtype == 'K')			// CKIN 
	{
	aBig = 0;
	vBig = 0;
	bBig = qBig;				// B = T
	}
    aa3Big = aBig.CSqr()*3.0;			// AA3 = A*A*3
    if (!juliaflag)
	zBig = -aBig;				// Z = -A
    return(TRUE);
    }

/**************************************************************************
	Run CUBIC type fractals
**************************************************************************/

int	do_big_cubic(void)

    {
    BigComplex	temp;

    if (subtype == 'K')						// CKIN
	zBig = zBig.CCube()+bBig;			// Z = Z*Z*Z + B
    else							// Z = Z*Z*Z - AA3*Z + B
	{
	temp = zBig.CCube()+bBig;				// Z = Z*Z*Z + B
	zBig = temp - aa3Big* zBig;			// Z = Z*Z*Z - AA3*Z + B
	}
    if (zBig.CSumSqr() >= 100.0)
	return (TRUE);
    else
	{
	if (subtype == 'F')
	    {
	    if (qBig.CSumSqr() <= 0.111111)
		{
		iteration = special;
		SpecialFlag = TRUE;					// for decomp and biomorph
		return (TRUE);
		}
	    vBig = zBig+a2Big;
	    }
	else if (subtype == 'K')
	    vBig = zBig - vBig;
	else
	    vBig = zBig - aBig;
	if (vBig.CSumSqr() <= 0.000001)
	    {
	    iteration = special;
	    SpecialFlag = TRUE;			// for decomp and biomorph
	    return (TRUE);
	    }
	}
    return(FALSE);
    }

/**************************************************************************
	Init type 5 fractal
**************************************************************************/

int	init_big_SpecialNewton(void)

    {
    l2Big = qBig.CSqr();
    aBig = -l2Big + 0.25;
    bBig = -(l2Big + 0.75);
    lm5Big = qBig - 0.5;
    lp5Big = qBig + 0.5;
    return(TRUE);
    }

/**************************************************************************
	Run type 5 fractals
**************************************************************************/

int	do_big_SpecialNewton(void)

    {
    BigComplex	temp1, temp2, z2Big;

    z2Big = zBig.CSqr();
    temp1 = z2Big * zBig.CDouble() + aBig;
    temp2 = z2Big * 3.0 + bBig;
    zBig = temp1/temp2;

    vBig = zBig - 1.0;
    if (vBig.CSumSqr() <= 0.000001)
	{
	phaseflag = 0;							// first phase
	return(TRUE);
	}
									    // v_real = dz_real - lm5_real;
    vBig = zBig - lm5Big;							// v_imag = dz_imag - lm5_imag;
    if (vBig.CSumSqr() <= 0.000001)
	{
	phaseflag = 1;							// second phase
	return(TRUE);
	}
									    // v_real = dz_real + lp5_real;
    vBig = zBig + lp5Big;							// v_imag = dz_imag + lp5_imag;
    if (vBig.CSumSqr() <= 0.000001)
	{
	phaseflag = 2;							// third phase
	return(TRUE);
	}
    return(FALSE);
    }

/**************************************************************************
	Init MATE fractals
**************************************************************************/

int	init_big_matein(void)

    {
    double	one = 1.0;
    int	i;

    period_level = FALSE;					// no periodicity checking
    if ((absolute = qBig.CSumSqr()) > one)
	return(-1);				// not inside set
    zBig.x = 1.0;
    zBig.y = 0.0;
						/* DO 300 I = 1,100 */
						/* 300  Z = L*(Z + 1/Z) */
    for (i = 0; i < 100; ++i)
	zBig = (zBig + zBig.CInvert()) * qBig;
    
    distance = 1.0;				// D = 1 
    ozBig = zBig.CInvert();			// OZ = 1/Z
    return(TRUE);
    }

/**************************************************************************
	Run MATE fractals
**************************************************************************/

int	do_big_matein(void)

    {
    double	epsilon = 0.01;
    double	escape = 10.0E20;
    BigComplex	t;

    zBig = qBig*(zBig+ozBig);			// Z = L*(Z + OZ)
    ozBig = zBig.CInvert();				// OZ = 1/Z
    t = -ozBig/ zBig;				// T = 1 - OZ/Z
    t.x = t.x + 1.0;
			    // D = D*ABSL*(REAL(T)*REAL(T) + IMAG(T)*IMAG(T))
    distance = distance * absolute * t.CSumSqr();

    if (distance <= epsilon)
	{
	phaseflag = 0;			// first phase
	return(TRUE);
	}
    if (distance > escape)
	{
	phaseflag = 1;			// second phase
	return(TRUE);
	}
    return(FALSE);
    }


/**************************************************************************
	Initialise SIN Fractal
***************************************************************************/

int	init_big_sin(void)

{
if (!juliaflag)
    {
    BigDouble BigPi;

    mpfr_const_pi(BigPi.x, MPFR_RNDN);

//    zBig.x = PI / 2.0;		// dz_real = HALF_PI;
    zBig.x = BigPi / 2.0;		// dz_real = HALF_PI;
    zBig.y = 0.0;
    }
return TRUE;
}

/**************************************************************************
	Determine count before 'Z' becomes unstable
	Z = L*SIN(Z)
	 sin(x+iy)  = sin(x)cosh(y) + icos(x)sinh(y)
***************************************************************************/

    int	do_big_sin(void)

    {
    BigDouble	a, b;

    zBig = qBig*zBig.CSin();
    a = 80.0;
    b = -80.0;

    if (zBig.x > a || zBig.x < b || zBig.y > a || zBig.y < b)
	return(TRUE);
    return(FALSE);
    }

#endif // SPLAT

/**************************************************************************
	Initialise Newton Polygon Fractal
***************************************************************************/

int	init_BigNewtonPolygon(void)  // Newton Polygon

    {
  /*
  Solve the roots of the function.
  Initialize z to one of the roots.
  Apply Newton's method for solving roots.
  f(z) = z - z/z'          
  
  For examply Newton Diamond (Z^4?)

  z   = z^5      + (z^4)*c   + z + c;  // the function
  z'  = 5*(z^4)  + 4*(z^3)*c + 1;      // 1st derivative
  z'' = 20*(z^3) + 12*(z^2)*c;         // 2nd derivative

  20*(z^3) = -12*(z^2)*c;
  z   = -(12*(z^2)*c)/(20*(z^2));       // solve for z
  z   = -(3*c)/5;

  ie init to:   z = -(3*c)/5;

  */

    if (!juliaflag)
	{
	zBig.x = -qBig.x * ((double)(degree - 2) / (double)degree + param[1]);
	zBig.y = -qBig.y * ((double)(degree - 2) / (double)degree + param[2]);
	}
    else
	zBig = qBig;
    return TRUE;
    }

/**************************************************************************
	Determine count before 'Z' becomes unstable
***************************************************************************/

int	do_BigNewtonPolygon(void)  // Newton Polygon

    {
    BigComplex	z1, fn, first, second, a, b, temp;
/*
  Solve the roots of the function.
  Initialize z to one of the roots.
  Apply Newton's method for solving roots.
  f(z) = z - z/z'          
  
  For example Newton Diamond

  z   = z^5      + (z^4)*c   + z + c;  // the function
  z'  = 5*(z^4)  + 4*(z^3)*c + 1;      // 1st derivative
  z'' = 20*(z^3) + 12*(z^2)*c;         // 2nd derivative

  20*(z^3) = -12*(z^2)*c;
  z   = -(12*(z^2)*c)/(20*(z^2));       // solve for z
  z   = -(3*c)/5;

  */

/*
  z = -(3*z)/5;
  d = 1;
  while( n_color++ < iteration
    && d > minsize)
  {
    z1 = z;
    z2 = z*z;
    z=z-(z2*z2*z + z2*z2*c + z + c)/(5*z2*z2 + 4*z2*z*c + 1);
    zd = z-z1;
    d = sum_sqrs_zd();
  }                   
}
*/                                                
    if (degree < 2)
	degree = 2; 
    z1 = zBig;
    second = zBig.CPolynomial(degree - 2);	// Z^degree - 2
    first = second * zBig;			// Z^degree - 1
    fn = first * zBig;				// Z^degree
    a = first* qBig+fn+ zBig+ qBig;
    b = first*((double)degree)+1.0+ qBig*(second*((double)(degree - 1)));
    zBig = zBig-a/b;
    temp = zBig - z1;

    return (temp.CSumSqr() < 1.0e-20);
    }

/**************************************************************************
	Determine count before 'Z' becomes unstable float version
***************************************************************************/

int	do_big_power(void)

    {
    zBig = qBig + zBig.CPolynomial(degree);
    return (zBig.CSumSqr() > 4.0);
    }

    #ifdef SPLAT
/**************************************************************************
	Run exponential type fractals
	Z = L*EXP(Z
	Complex Exponent: e^(x+iy) = (e^x) * cos(y) + i * (e^x) * sin(y)
**************************************************************************/

int	do_big_exp(void)

    {
    int		compare;
    BigDouble	a, b;

    zBig = qBig*zBig.CExp();			    // Z = L*EXP(Z)
    a = 10.0;
    b = -10.0;

    switch (subtype)
	{
	case 'R':
	    compare = (zBig.x > a);
	    break;
	case 'I':
	    compare = (zBig.y > a);
	    break;
	case 'M':
	    compare = (zBig.x > a || zBig.x < b || zBig.y > a || zBig.y < b);
	    break;
	default:
	    compare = (zBig.x > a);
	    break;
	}
    if (compare)
	return(TRUE);
    return(FALSE);
    }

/****************************************************************
    Mandelbar (Tricorn)
****************************************************************/
/*
int	Do_big_Mandelbar(void)
    {
    BigDouble realimagBig;
    BigComplex	sqrBig;

    sqrBig.x = zBig.x.BigSqr();
    sqrBig.y = zBig.y.BigSqr();
    if (degree == 2)
	{
	realimagBig = zBig.x * zBig.y;
	zBig.x = qBig.x + sqrBig.x - sqrBig.y;
	zBig.y = qBig.y - realimagBig - realimagBig;
	}
    else
	{
	zBig = zBig.CPolynomial(degree);
	zBig.y = (param[3] == 1.0 ? zBig.y : -zBig.y) + qBig.y;
	zBig.x = (param[3] == 1.0 ? -zBig.x : zBig.x) + qBig.x;
	}
    return (sqrBig.x + sqrBig.y > BigBailout);

    sqr.x = z.x * z.x;
    sqr.y = z.y * z.y; 
    if (degree == 2)
	{
	real_imag = z.x * z.y;
	z.x = sqr.x - sqr.y + q.x;
	z.y = -real_imag - real_imag + q.y;
	}
    else
	{
	z = CPolynomial(z, degree);	
	z.x = z.x + q.x;
	z.y = -z.y + q.y;
	}
    return ((sqr.x + sqr.y) >= rqlim);
*/
    }

/**************************************************************************
	Initialise RedShiftRider
***************************************************************************/

int	init_big_RedShiftRider(void)

    {
/*
    a.x = param[0];
    a.y = param[1];
    degree = (int)param[2];
    if (!juliaflag)
	{
	z.x = q.x + param[3];
	z.y = q.y + param[4];
	}
*/
 //   ShowBignum(qBig.x, "q.x");
 //   ShowBignum(qBig.y, "q.y");
    aBig.x = param[0];
    aBig.y = param[1];
    degree = (BYTE)param[2];
    if (!juliaflag)
	{
	zBig.x = qBig.x + param[3];
	zBig.y = qBig.y + param[4];
	}
    return 0;
    }

/**************************************************************************
	Run RedShiftRider type fractals
	a*z^2 +/- z^n + c
**************************************************************************/

int	Do_big_RedShiftRider(void)

    {
//    z = a * z * z + ((param[4] == 1.0) ? 1.0 : -1.0) * CPolynomial(z, degree);
//    z = z+q;
//    return (CSumSqr(z) >= rqlim);
    zBig = aBig * zBig * zBig + zBig.CPolynomial(degree) * ((param[5] == 1.0) ? 1.0 : -1.0);
    zBig = zBig + qBig;
    return (zBig.CSumSqr() > 4.0);
    }

/**************************************************************************
	Talis Power Fractal
***************************************************************************/

int	InitBigTalisPower(void)  // Talis

    {
    degree = (int)param[0];
    if (degree < 1)
	degree = 1;
    if (!juliaflag)
	{
	zBig.x = qBig.x + param[2];
	zBig.y = qBig.y + param[3];
	}
    return 0;
    }

int	doBigTalisPower(void)  // Talis    Z = Z^N/(M + Z^(N-1)) + C

    {
    double	m;
    BigComplex	z1;

    m = param[1];
    z1 = zBig.CPolynomial(degree - 1);
    zBig = (z1 * zBig) / (z1 + m) + qBig;
    return (zBig.CSumSqr() >= rqlim);
    }

/**************************************************************************
	Polynomial Fractal
***************************************************************************/

int	InitBigPolynomial(void)
    {
    init_big_mandel();
    for (int i = 0; i < MAXPOLYDEG; i++)			// find highest order of polynomial
	{
	if (param[2 + i] != 0.0)
	    {
	    fractalspecific[type].SlopeDegree = MAXPOLYDEG - i;
	    break;
	    }
	}
    return 0;
    }

int	doBigPolynomial(void)
    {
    BigComplex	InitialZ = zBig;
    BigComplex	FinalZ = { 0.0, 0.0 };
    
    for (int m = 0; m < MAXPOLYDEG; m++)
	{
	BigComplex BigComplexTemp = InitialZ;
	if (param[2 + m] != 0.0)
	    {
	    for (int k = 0; k < MAXPOLYDEG - m - 1; k++)
		BigComplexTemp *= InitialZ;
	    FinalZ += (BigComplexTemp * param[2 + m]);
	    }
	}
    zBig = FinalZ + qBig;
    return (zBig.CSumSqr() >= rqlim);
    }
#endif 
#endif 

